<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Dice: Hybrid Overdrive</title>
    <style>
        :root { --primary: #00f3ff; --danger: #ff0055; --ammo: #ffcc00; --bg: #05050a; }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Courier New', Courier, monospace; touch-action: none; }
        
        #ui { position: absolute; top: 20px; left: 20px; color: var(--primary); font-size: 24px; font-weight: bold; text-shadow: 0 0 10px var(--primary); z-index: 10; pointer-events: none; }
        #ammo-ui.critical { color: var(--danger); text-shadow: 0 0 20px var(--danger); animation: pulse 0.6s infinite alternate; }

        @keyframes pulse { from { opacity: 1; } to { opacity: 0.5; } }

        .modal { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); padding: 40px; border: 3px solid var(--primary); color: white; text-align: center; z-index: 20; width: 80%; max-width: 500px; }
        button { background: var(--primary); border: none; padding: 15px 40px; font-size: 20px; cursor: pointer; font-weight: bold; margin-top: 20px; width: 100%; }
        .hint { font-size: 14px; color: #888; margin-top: 15px; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="ui">
        DISTANCE: <span id="dist-val">0</span><br>
        <span id="ammo-ui">AMMO: <span id="ammo-val">12</span></span>
    </div>

    <div id="start-screen" class="modal">
        <h1 style="color: var(--primary); letter-spacing: 5px;">AUTO-STRIKER</h1>
        <p><b>W/S or Arrows:</b> Switch Lanes</p>
        <p><b>Space:</b> Jump over Pits</p>
        <p style="color: var(--ammo); margin-top: 10px;"><b>AUTO-FIRE ENABLED:</b><br>Spikes in your lane are shot automatically.</p>
        <button onclick="startGame()">INITIALIZE</button>
        <div class="hint">Works with Keyboard or Touch Zones</div>
    </div>

    <script>
        const SPEED = 22.0;
        const GRAVITY = -65.0;
        const JUMP_FORCE = 24.0;
        const LANES = [-3.5, 0, 3.5];

        let scene, camera, renderer, clock, playerGroup;
        let isPlaying = false, score = 0, ammo = 12;
        let currentLane = 1, targetRotationX = 0;
        let velocityY = 0, isGrounded = false;
        let lastAutoFire = 0;
        
        let obstacles = [], particles = [], lasers = [], pickUps = [];

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x05050a, 15, 90);
            clock = new THREE.Clock();
            
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(15, 9, 15);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const pointLight = new THREE.PointLight(0x00f3ff, 2, 50);
            scene.add(pointLight);

            // Player Dice
            playerGroup = new THREE.Group();
            const core = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 1.2), new THREE.MeshStandardMaterial({ color: 0x001a1a }));
            const wireframe = new THREE.LineSegments(
                new THREE.EdgesGeometry(core.geometry), 
                new THREE.LineBasicMaterial({ color: 0x00f3ff, linewidth: 2 })
            );
            playerGroup.add(core, wireframe);
            scene.add(playerGroup);

            // Track Lanes
            LANES.forEach(z => {
                const lane = new THREE.Mesh(new THREE.BoxGeometry(10000, 0.1, 2.8), new THREE.MeshStandardMaterial({ color: 0x111122 }));
                lane.position.set(4900, -0.05, z);
                scene.add(lane);
            });

            // --- INPUTS: KEYBOARD ---
            window.addEventListener('keydown', (e) => {
                if (!isPlaying) return;
                if ((e.code === 'KeyW' || e.code === 'ArrowUp') && currentLane > 0) { currentLane--; targetRotationX -= Math.PI / 2; }
                if ((e.code === 'KeyS' || e.code === 'ArrowDown') && currentLane < 2) { currentLane++; targetRotationX += Math.PI / 2; }
                if (e.code === 'Space' && isGrounded) { velocityY = JUMP_FORCE; isGrounded = false; }
            });

            // --- INPUTS: TOUCH (Mobile Friendly) ---
window.addEventListener('touchstart', (e) => {
    if (!isPlaying) return;
    const touchX = e.touches[0].clientX / window.innerWidth;
    
    // Tap Left Side: Move UP (Decrease index)
    if (touchX < 0.3) { 
        if (currentLane < 2) { 
            currentLane++; 
            targetRotationX += Math.PI / 2; 
        } 
    } 
    // Tap Right Side: Move DOWN (Increase index)
    else if (touchX > 0.7) { 
        if (currentLane >0 ) { 
            currentLane--; 
            targetRotationX -= Math.PI / 2; 
        } 
    } 
    // Tap Center: Jump
    else { 
        if (isGrounded) { 
            velocityY = JUMP_FORCE; 
            isGrounded = false; 
        } 
    }
}, { passive: false });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
        }

        function autoShoot() {
            // Check cooldown and ammo
            if (ammo <= 0 || Date.now() - lastAutoFire < 250) return;

            // Target spikes in current lane within 35 units distance
            let spikeTarget = obstacles.find(obs => 
                obs.userData.type === "spike" && 
                Math.abs(obs.position.z - LANES[currentLane]) < 1 &&
                obs.position.x > playerGroup.position.x &&
                obs.position.x < playerGroup.position.x + 35
            );

            if (spikeTarget) {
                const laserColor = (ammo < 10) ? 0xff0055 : 0x00f3ff;
                ammo--;
                lastAutoFire = Date.now();
                
                const laser = new THREE.Mesh(new THREE.BoxGeometry(3, 0.2, 0.2), new THREE.MeshBasicMaterial({ color: laserColor }));
                laser.position.copy(playerGroup.position);
                scene.add(laser);
                lasers.push(laser);
                updateUI();
            }
        }

        function updateUI() {
            document.getElementById('ammo-val').innerText = ammo;
            document.getElementById('dist-val').innerText = Math.floor(score);
            const ammoBox = document.getElementById('ammo-ui');
            if (ammo < 10) ammoBox.classList.add('critical');
            else ammoBox.classList.remove('critical');
        }

        function spawnEntities() {
            if (score < 40) return;
            if (Math.random() < 0.04) {
                const laneIdx = Math.floor(Math.random() * 3);
                const isPit = Math.random() > 0.85;
                let mesh;
                if (isPit) {
                    mesh = new THREE.Mesh(new THREE.BoxGeometry(6, 0.5, 3), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                    mesh.userData.type = "pit";
                    mesh.position.set(playerGroup.position.x + 80, -0.3, LANES[laneIdx]);
                } else {
                    mesh = new THREE.Mesh(new THREE.ConeGeometry(0.8, 2, 4), new THREE.MeshStandardMaterial({ color: 0xff0055, emissive: 0xff0055 }));
                    mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(mesh.geometry), new THREE.LineBasicMaterial({color: 0xffffff})));
                    mesh.position.set(playerGroup.position.x + 80, 1, LANES[laneIdx]);
                    mesh.userData.type = "spike";
                }
                scene.add(mesh);
                obstacles.push(mesh);
            }
            // Rare Ammo Spawn
            if (Math.random() < 0.003) {
                const orb = new THREE.Mesh(new THREE.SphereGeometry(0.6, 12, 12), new THREE.MeshStandardMaterial({ color: 0xffcc00, emissive: 0xffcc00, emissiveIntensity: 2 }));
                orb.position.set(playerGroup.position.x + 80, 1, LANES[Math.floor(Math.random()*3)]);
                scene.add(orb);
                pickUps.push(orb);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            if (!isPlaying) return;

            playerGroup.position.x += SPEED * dt;
            score += SPEED * dt;
            updateUI();

            // Movement
            playerGroup.position.z = THREE.MathUtils.lerp(playerGroup.position.z, LANES[currentLane], 0.15);
            playerGroup.rotation.x = THREE.MathUtils.lerp(playerGroup.rotation.x, targetRotationX, 0.15);

            velocityY += GRAVITY * dt;
            playerGroup.position.y += velocityY * dt;
            if (playerGroup.position.y <= 0.6) { playerGroup.position.y = 0.6; velocityY = 0; isGrounded = true; }

            // Camera follow
            camera.position.x = playerGroup.position.x + 14;
            camera.lookAt(playerGroup.position.x + 2, 1, 0);

            autoShoot();

            // Laser vs Spikes
            for (let i = lasers.length - 1; i >= 0; i--) {
                const l = lasers[i];
                l.position.x += 80 * dt;
                const lBox = new THREE.Box3().setFromObject(l);
                obstacles.forEach((obs, oIdx) => {
                    if (obs.userData.type === "spike" && lBox.intersectsBox(new THREE.Box3().setFromObject(obs))) {
                        scene.remove(obs); obstacles.splice(oIdx, 1);
                        scene.remove(l); lasers.splice(i, 1);
                    }
                });
                if (l.position.x > playerGroup.position.x + 80) { scene.remove(l); lasers.splice(i, 1); }
            }

            // High-density trail
            for(let i=0; i<3; i++) {
                const p = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.2), new THREE.MeshBasicMaterial({ color: 0x00f3ff, transparent: true, opacity: 0.5 }));
                p.position.copy(playerGroup.position).add(new THREE.Vector3(-0.6, (Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5));
                scene.add(p);
                particles.push({ mesh: p, life: 1.0 });
            }
            particles.forEach((p, i) => {
                p.life -= dt * 2.5; p.mesh.material.opacity = p.life;
                if (p.life <= 0) { scene.remove(p.mesh); particles.splice(i, 1); }
            });

            // Pickups
            pickUps.forEach((orb, i) => {
                orb.rotation.y += 0.05;
                if (playerGroup.position.distanceTo(orb.position) < 1.8) { ammo += 5; scene.remove(orb); pickUps.splice(i, 1); updateUI(); }
            });

            spawnEntities();

            // Collisions
            const pBox = new THREE.Box3().setFromObject(playerGroup).expandByScalar(-0.25);
            obstacles.forEach((obs, i) => {
                if (pBox.intersectsBox(new THREE.Box3().setFromObject(obs))) {
                    if (obs.userData.type === "spike" || (obs.userData.type === "pit" && isGrounded)) {
                        isPlaying = false; location.reload();
                    }
                }
                if (obs.position.x < playerGroup.position.x - 20) { scene.remove(obs); obstacles.splice(i, 1); }
            });

            renderer.render(scene, camera);
        }

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            isPlaying = true;
            clock.start();
        }

        init();
    </script>
</body>
</html>