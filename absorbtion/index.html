<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Celestial Eater - Universal Propulsion</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; font-family: 'Segoe UI', Tahoma, sans-serif; touch-action: none; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: white; pointer-events: none;
            background: rgba(0, 0, 0, 0.8); padding: 20px; border-radius: 12px; border: 1px solid #00ff8844;
            min-width: 200px;
            z-index: 10;
        }
        #stats { color: #00ff88; font-weight: bold; font-size: 1.5rem; }
        #dom-label { font-size: 0.75rem; color: #aaa; margin-top: 8px; text-transform: uppercase; }
        #progress-bar { width: 100%; height: 8px; background: #111; margin-top: 10px; border-radius: 4px; overflow: hidden; border: 1px solid #333; }
        #progress-fill { width: 0%; height: 100%; background: #00ff88; transition: width 0.2s; box-shadow: 0 0 10px #00ff88; }
        
        /* MODIFIED MINIMAP CSS */
        #minimap-container {
            position: absolute; bottom: 25px; right: 25px; width: 220px; height: 220px;
            z-index: 10;
            pointer-events: none;
            /* Removed border, radius, background, and shadow */
        }

        #win-screen {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95); color: #00ff88; padding: 50px; border-radius: 25px;
            text-align: center; border: 2px solid #00ff88; display: none; z-index: 100;
        }
        button { background: #00ff88; border: none; padding: 12px 30px; border-radius: 8px; cursor: pointer; font-weight: bold; margin-top: 25px; }

        /* --- MOBILE CONTROLS CSS --- */
        #joystick-zone {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(0, 255, 136, 0.3);
            border-radius: 50%;
            z-index: 20;
            display: none; 
        }
        #joystick-knob {
            position: absolute;
            top: 50%; left: 50%;
            width: 50px; height: 50px;
            background: rgba(0, 255, 136, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
        }
        
        @media (hover: none) and (pointer: coarse) {
            #joystick-zone { display: block; }
            #ui { transform: scale(0.8); transform-origin: top left; }
            #minimap-container { transform: scale(0.7); transform-origin: bottom right; }
        }
    </style>
</head>
<body>

    <div id="ui">
        <div id="stats">MASS: 2.20</div>
        <div id="dom-label">Universe Domination: <span id="dom-percent">0</span>%</div>
        <div id="progress-bar"><div id="progress-fill"></div></div>
    </div>

    <div id="win-screen">
        <h1>ASCENDED</h1>
        <p>You have consumed 80% of all current matter.</p>
        <button onclick="location.reload()">RESTART CYCLE</button>
    </div>

    <div id="joystick-zone">
        <div id="joystick-knob"></div>
    </div>

    <div id="minimap-container"></div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- GAME TUNING ---
        const WORLD_SIZE = 550;
        const TOTAL_CIRCLES = 95;      
        const SMART_CIRCLE_COUNT = 10; 
        
        const INITIAL_DRIFT = 0.08;    
        const ACCEL = 0.0014;          
        const MAX_SPEED = 0.65;        
        const SHRINK = 0.0011;         
        const SIPHON = 0.95;           

        const scene = new THREE.Scene();
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.autoClear = false;
        document.body.appendChild(renderer.domElement);

        const aspect = window.innerWidth / window.innerHeight;
        const viewSize = 85; 
        
        const camera = new THREE.OrthographicCamera(-viewSize*aspect/2, viewSize*aspect/2, viewSize/2, -viewSize/2, 0.1, 1000);
        camera.position.z = 100;
        camera.layers.set(0); 

        const miniCamera = new THREE.OrthographicCamera(-WORLD_SIZE/2, WORLD_SIZE/2, WORLD_SIZE/2, -WORLD_SIZE/2, 0.1, 1000);
        miniCamera.position.z = 100;
        miniCamera.layers.enable(1); 

        scene.add(new THREE.AmbientLight(0xffffff, 1.2));
        const grid = new THREE.GridHelper(WORLD_SIZE, 60, 0x00ff88, 0x111111);
        grid.rotation.x = Math.PI / 2;
        scene.add(grid);

        let circles = [];
        let particles = [];
        const keys = {};
        let gameWon = false;

        // --- JOYSTICK LOGIC START ---
        const joystickZone = document.getElementById('joystick-zone');
        const joystickKnob = document.getElementById('joystick-knob');
        let joystickVec = { x: 0, y: 0 };
        let joystickActive = false;
        let joyTouchId = null;
        const joyRadius = 60; 

        joystickZone.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            joyTouchId = touch.identifier;
            joystickActive = true;
            updateJoystick(touch.clientX, touch.clientY);
        }, { passive: false });

        joystickZone.addEventListener('touchmove', (e) => {
            e.preventDefault();
            for(let i=0; i<e.changedTouches.length; i++){
                if(e.changedTouches[i].identifier === joyTouchId) {
                    updateJoystick(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
                    break;
                }
            }
        }, { passive: false });

        const resetJoystick = (e) => {
            let myTouchEnded = false;
            if(!e) { myTouchEnded = true; } 
            else {
                for(let i=0; i<e.changedTouches.length; i++){
                    if(e.changedTouches[i].identifier === joyTouchId) myTouchEnded = true;
                }
            }
            if(myTouchEnded) {
                joystickActive = false;
                joystickVec = { x: 0, y: 0 };
                joystickKnob.style.transform = `translate(-50%, -50%)`;
                joyTouchId = null;
            }
        };

        joystickZone.addEventListener('touchend', resetJoystick);
        joystickZone.addEventListener('touchcancel', resetJoystick);

        function updateJoystick(clientX, clientY) {
            const rect = joystickZone.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            let dx = clientX - centerX;
            let dy = clientY - centerY;
            const distance = Math.sqrt(dx*dx + dy*dy);

            if (distance > joyRadius) {
                const ratio = joyRadius / distance;
                dx *= ratio;
                dy *= ratio;
            }

            joystickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            joystickVec.x = dx / joyRadius;
            joystickVec.y = -(dy / joyRadius);
        }
        // --- JOYSTICK LOGIC END ---

        const playerGlow = new THREE.Mesh(
            new THREE.RingGeometry(1.5, 2.5, 32), 
            new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.9 })
        );
        playerGlow.layers.set(1); 
        scene.add(playerGlow);

        function createParticle(x, y, color, velX, velY, size) {
            const pMesh = new THREE.Mesh(new THREE.CircleGeometry(size, 8), new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.8 }));
            pMesh.position.set(x, y, 0.1);
            pMesh.layers.set(0);
            const spread = 0.03;
            particles.push({ mesh: pMesh, life: 1.0, vel: new THREE.Vector2(velX + (Math.random()-0.5)*spread, velY + (Math.random()-0.5)*spread) });
            scene.add(pMesh);
        }

        function createCircle(x, y, radius, color, isPlayer = false, isSmart = false) {
            const mesh = new THREE.Mesh(new THREE.CircleGeometry(1, 48), new THREE.MeshPhongMaterial({ color, shininess: 40 }));
            mesh.position.set(x, y, 0.2);
            mesh.layers.set(0);

            let indicator = null;
            if (isSmart) {
                indicator = new THREE.Mesh(new THREE.RingGeometry(0.8, 1.1, 16), new THREE.MeshBasicMaterial({ color: 0xff3333, transparent: true, opacity: 0.7 }));
                indicator.layers.set(1); 
                scene.add(indicator);
            }
            
            const angle = Math.random() * Math.PI * 2;
            const velocity = isPlayer ? new THREE.Vector2(0,0) : new THREE.Vector2(Math.cos(angle) * INITIAL_DRIFT, Math.sin(angle) * INITIAL_DRIFT);

            const circle = { 
                mesh, radius, isPlayer, isSmart, indicator, removed: false, 
                vel: velocity
            };
            scene.add(mesh);
            circles.push(circle);
            return circle;
        }

        let player = createCircle(0, 0, 2.2, 0x00ff88, true, false);

        for (let i = 0; i < TOTAL_CIRCLES; i++) {
            const isSmart = i < SMART_CIRCLE_COUNT;
            const color = isSmart ? new THREE.Color(0xff4444).setHSL(Math.random(), 0.9, 0.4) : new THREE.Color().setHSL(Math.random(), 0.3, 0.5);
            createCircle((Math.random()-0.5)*(WORLD_SIZE-60), (Math.random()-0.5)*(WORLD_SIZE-60), Math.random()*(isSmart ? 4 : 2.5) + 0.8, color, false, isSmart);
        }

        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);
        window.addEventListener('resize', () => {
             const aspect = window.innerWidth / window.innerHeight;
             camera.left = -viewSize*aspect/2;
             camera.right = viewSize*aspect/2;
             camera.top = viewSize/2;
             camera.bottom = -viewSize/2;
             camera.updateProjectionMatrix();
             renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate(time) {
            if (gameWon) return;
            requestAnimationFrame(animate);

            // 1. INPUT
            let pThrust = new THREE.Vector2(0,0);
            if (keys['KeyW'] || keys['ArrowUp']) pThrust.y += 1;
            if (keys['KeyS'] || keys['ArrowDown']) pThrust.y -= 1;
            if (keys['KeyA'] || keys['ArrowLeft']) pThrust.x -= 1;
            if (keys['KeyD'] || keys['ArrowRight']) pThrust.x += 1;
            
            if (joystickActive) {
                pThrust.x += joystickVec.x;
                pThrust.y += joystickVec.y;
            }

            if (pThrust.length() > 0) {
                if(pThrust.length() > 1) pThrust.normalize();
                player.vel.addScaledVector(pThrust, ACCEL);
                player.radius -= SHRINK;
                for(let i=0; i<3; i++) {
                    const sx = player.mesh.position.x - (pThrust.x * player.radius);
                    const sy = player.mesh.position.y - (pThrust.y * player.radius);
                    createParticle(sx, sy, 0x00ff88, -pThrust.x*0.25, -pThrust.y*0.25, Math.max(0.1, player.radius * 0.12));
                }
            }

            // 2. MASS & AI
            let totalUniverseMass = 0;
            let playerMass = Math.PI * Math.pow(player.radius, 2);

            circles.forEach(c => {
                if (c.removed) return;
                totalUniverseMass += Math.PI * Math.pow(c.radius, 2);

                if (c.isSmart && !c.isPlayer) {
                    let target = null;
                    let minDist = 180;
                    circles.forEach(other => {
                        if (other === c || other.removed) return;
                        if (c.radius > other.radius * 1.1) {
                            let d = c.mesh.position.distanceTo(other.mesh.position);
                            if (d < minDist) { minDist = d; target = other; }
                        }
                    });
                    if (target) {
                        let aiThrust = new THREE.Vector2().subVectors(target.mesh.position, c.mesh.position).normalize();
                        c.vel.addScaledVector(aiThrust, ACCEL * 0.8);
                        c.radius -= SHRINK * 0.45;
                        
                        if (Math.random() > 0.4) {
                             const sx = c.mesh.position.x - (aiThrust.x * c.radius);
                             const sy = c.mesh.position.y - (aiThrust.y * c.radius);
                             createParticle(sx, sy, c.mesh.material.color, -aiThrust.x*0.2, -aiThrust.y*0.2, c.radius * 0.1);
                        }
                    }
                }
                if (c.vel.length() > MAX_SPEED) c.vel.setLength(MAX_SPEED);
            });

            // 3. PHYSICS
            for (let i = 0; i < circles.length; i++) {
                const a = circles[i];
                if (a.removed) continue;
                
                a.mesh.position.x += a.vel.x;
                a.mesh.position.y += a.vel.y;
                const visualScale = Math.max(0.1, a.radius);
                a.mesh.scale.set(visualScale, visualScale, 1);
                
                if (a.indicator) {
                    a.indicator.position.copy(a.mesh.position);
                    a.indicator.scale.set(visualScale * 1.4, visualScale * 1.4, 1);
                    a.indicator.material.opacity = 0.3 + Math.sin(time * 0.01) * 0.2;
                }

                const limit = WORLD_SIZE/2 - a.radius;
                if (Math.abs(a.mesh.position.x) > limit) { a.vel.x *= -1; a.mesh.position.x = Math.sign(a.mesh.position.x)*limit; }
                if (Math.abs(a.mesh.position.y) > limit) { a.vel.y *= -1; a.mesh.position.y = Math.sign(a.mesh.position.y)*limit; }

                for (let j = i + 1; j < circles.length; j++) {
                    const b = circles[j];
                    if (b.removed) continue;
                    const dx = b.mesh.position.x - a.mesh.position.x;
                    const dy = b.mesh.position.y - a.mesh.position.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const minDist = a.radius + b.radius;

                    if (dist < minDist + 1.0) {
                        if (dist < minDist) {
                            const overlap = minDist - dist;
                            const massA = a.radius * a.radius;
                            const massB = b.radius * b.radius;
                            const totalM = massA + massB;
                            const nx = dx/dist; const ny = dy/dist;
                            a.mesh.position.x -= nx * overlap * (massB/totalM);
                            a.mesh.position.y -= ny * overlap * (massB/totalM);
                            b.mesh.position.x += nx * overlap * (massA/totalM);
                            b.mesh.position.y += ny * overlap * (massA/totalM);
                        }
                        const bigger = a.radius > b.radius ? a : b;
                        const smaller = a.radius > b.radius ? b : a;
                        smaller.radius -= SIPHON * 0.02;
                        bigger.radius += SIPHON * 0.018;
                        if (smaller.radius <= 0.5) {
                            smaller.removed = true;
                            scene.remove(smaller.mesh);
                            if(smaller.indicator) scene.remove(smaller.indicator);
                        }
                    }
                }
            }

            // 4. UI & RENDER
            const domination = playerMass / totalUniverseMass;
            document.getElementById('progress-fill').style.width = `${Math.min((domination / 0.8) * 100, 100)}%`;
            document.getElementById('dom-percent').innerText = Math.min(Math.floor(domination * 100), 100);
            if (domination >= 0.8) { gameWon = true; document.getElementById('win-screen').style.display = 'block'; }

            particles.forEach((p, idx) => {
                p.mesh.position.x += p.vel.x; p.mesh.position.y += p.vel.y;
                p.life -= 0.035; p.mesh.material.opacity = p.life;
                if(p.life <= 0) { scene.remove(p.mesh); particles.splice(idx, 1); }
            });
            
            playerGlow.position.copy(player.mesh.position);
            playerGlow.scale.set(Math.max(0.1, player.radius) * 1.9, Math.max(0.1, player.radius) * 1.9, 1);
            playerGlow.material.opacity = (player.radius < 0.6) ? 0 : 0.5 + Math.sin(time * 0.008) * 0.4;

            renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
            renderer.clear();
            camera.position.x += (player.mesh.position.x - camera.position.x) * 0.1;
            camera.position.y += (player.mesh.position.y - camera.position.y) * 0.1;
            camera.zoom += ( (1.0 / (1 + (player.radius - 2) * 0.12)) - camera.zoom) * 0.05;
            camera.updateProjectionMatrix();
            renderer.render(scene, camera);

            const miniSize = 220;
            renderer.setScissorTest(true);
            renderer.setScissor(window.innerWidth - miniSize - 25, 25, miniSize, miniSize);
            renderer.setViewport(window.innerWidth - miniSize - 25, 25, miniSize, miniSize);
            grid.visible = false; renderer.render(scene, miniCamera); grid.visible = true;
            renderer.setScissorTest(false);

            document.getElementById('stats').innerText = `MASS: ${player.radius.toFixed(2)}`;
            if (player.radius < 0.51) location.reload();
            circles = circles.filter(c => !c.removed);
        }
        animate(0);
    </script>
</body>
</html>